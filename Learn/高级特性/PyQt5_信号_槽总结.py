# 在接下来Qt designer这一章也会详细讨论这个问题，
# 我们使用Qt designer来设计和修改ui文件——对应程序中大部分的静态视图元素，
# 主要的目的倒不是为了快速GUI程序编写，其实写代码也挺快的，主要的目的就是为了代码复用。
#
# 当我们养成习惯，强迫自己程序中的静态视图元素都进入ui文件，这不仅增强了ui文件的复用性，
# 而且也增强了剩下来的python代码的复用性。
# 这其中很大一部分就是这里讨论的信号－槽机制的功劳。

# 当我们自定义的类加载好ui文件之后，该类里面的代码实际上就剩下两个工作：

    # 把本窗体的信号和槽都编写好
    # 把母窗体和子窗体和信号－槽接口写好。

# 一般程序的用户互动接口大多在最顶层，也就是用户一般喜欢在菜单栏找到所有可能对程序的控制，
# 这些控制的实现函数如果放在都放在母窗体，那么整个程序的代码复用性会降到最低，
#
# 而如果我们将这些实现函数分别移到和其视图窗体最紧密的窗体类中，那么不仅代码复用性会大大提高，
# 而且这些槽或函数的编写也会简单很多。
#
# 那么我们该如何组织这些信号和槽（实现函数）呢？
#
# 我在这里提出组织学上的一些抽象原则：

    # 最小组织原则，凡是小组织能够自我实现的功能绝不上传到更大一级的组织中去。
    # 大组织对小组织元素的某些实现的引用，采用明文引用原则。
    # 比如说母窗体中有一个小窗体有一个编辑器，母窗体想要操控这个编辑器执行剪切操作，那么采用明文引用，
    # 也就是self.textEdit.cut。

    # 小组织对大组织属性的引用采用信号激活原则，比如说某个编辑器发生了内容修改，
    # 你可以自定义一个信号，该信号为标题修改信号，然后信号触发母窗体的某个方法，这样达到修改母窗体的标题的目的。
    #
    # 而在母窗体中，只需要在声明是将小组织的信号和大组织的某个方法连接起来即可。

